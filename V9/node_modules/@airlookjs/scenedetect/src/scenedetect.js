import child_process from 'child_process';
import path from 'path';
import { promisify } from 'util';
import fs from 'fs';
import { parse as csvLibParse } from 'csv-parse';
export const SCENEDETECT_CMD = 'scenedetect';
export const scenedetectVersion = async () => {
    const execFile = promisify(child_process.execFile);
    const { stdout, stderr } = await execFile(SCENEDETECT_CMD, ['version']);
    if (stderr) {
        console.error('exec stderr', stderr);
        throw new Error(stderr);
    }
    return stdout;
};
const findSceneImages = (sceneNumber, cachePath) => {
    return ['1', '2', '3'].map((indicies) => {
        return path.join(cachePath, `${sceneNumber.padStart(3, '0')}-${indicies.padStart(2, '0')}.jpg`);
    });
};
const mapCsvToScenes = ({ csvData, cachePath, hasImages }) => {
    const mappedScenes = csvData.map(([sceneNumber, startFrame, startTimecode, startTimeSeconds, endFrame, endTimecode, endTimeSeconds]) => {
        const scene = {
            index: parseInt(sceneNumber),
            start: {
                frame: parseInt(startFrame),
                timecode: startTimecode,
                seconds: parseFloat(startTimeSeconds)
            },
            end: {
                frame: parseInt(endFrame),
                timecode: endTimecode,
                seconds: parseFloat(endTimeSeconds)
            }
        };
        if (hasImages) {
            const imagePaths = findSceneImages(sceneNumber, cachePath);
            if (fs.existsSync(imagePaths[0])) {
                scene.start.image = path.basename(imagePaths[0]);
            }
            if (fs.existsSync(imagePaths[1])) {
                scene.image = path.basename(imagePaths[1]);
            }
            if (fs.existsSync(imagePaths[2])) {
                scene.end.image = path.basename(imagePaths[2]);
            }
        }
        return scene;
    });
    return mappedScenes;
};
export async function getScenes({ file, cachePath }) {
    console.log('Detecting scenes for: ' + file);
    const canSaveImages = !!cachePath;
    if (!cachePath) {
        cachePath = path.join('/tmp/scenedetect/', path.basename(file) + '/');
    }
    const scenedetectArgs = [
        '--verbosity', 'error',
        '--input', file,
        'detect-adaptive',
        'list-scenes',
        '--skip-cuts',
        '--output', cachePath,
    ];
    if (canSaveImages) {
        scenedetectArgs.push('save-images', '--filename', '$SCENE_NUMBER-$IMAGE_NUMBER', '--output', cachePath);
    }
    const execFile = promisify(child_process.execFile);
    const csvParse = promisify(csvLibParse);
    const { stderr } = await execFile(SCENEDETECT_CMD, scenedetectArgs);
    if (stderr) {
        console.error('stderr', stderr);
    }
    const csvContent = fs.readFileSync(path.join(cachePath, `${path.basename(file, path.extname(file))}-Scenes.csv`), 'utf8');
    const csvData = await csvParse(csvContent, { delimiter: ',', fromLine: 2 });
    const output = {
        scenedetect: {
            scenes: mapCsvToScenes({ csvData, cachePath, hasImages: canSaveImages })
        }
    };
    if (!canSaveImages) {
        fs.rmSync(cachePath, { recursive: true, force: true });
    }
    return output;
}
//# sourceMappingURL=scenedetect.js.map