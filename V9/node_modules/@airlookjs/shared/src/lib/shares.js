import { v4 as uuid } from 'uuid';
import { FileNotFoundError } from './FileNotFoundError.js';
import { pipeline } from 'node:stream/promises';
import got from 'got';
import path from "node:path";
import fs from 'fs';
import { readCached, writeCached } from './cache.js';
export const matchShare = (searchPath, share) => {
    for (const match of share.matches) {
        const matchResult = searchPath.match(match);
        if (matchResult?.[1]) {
            return matchResult[1];
        }
    }
    return false;
};
export const findPathInShares = (searchPath, shares) => {
    const matchedShares = [];
    for (const share of shares) {
        const match = matchShare(searchPath, share);
        if (match) {
            matchedShares.push(share);
            const filePath = path.join(share.mount, match);
            if (fs.existsSync(filePath)) {
                return {
                    share,
                    filePath
                };
            }
        }
    }
    if (matchedShares.length > 0) {
        throw new Error(`File ${searchPath} not found on any matched shares. Matched shares: ${matchedShares.map(share => share.name).join(', ')}`);
    }
    throw new Error(`File ${searchPath} not matching any shares.`);
};
const waitForAlreadyRunningJob = async (lockFilePath) => {
    if (fs.existsSync(lockFilePath)) {
        console.info('Job is already running for this file');
        await new Promise((resolve) => {
            const interval = setInterval(() => {
                if (!fs.existsSync(lockFilePath)) {
                    clearInterval(interval);
                    resolve();
                }
                else {
                    const lockFileStats = fs.statSync(lockFilePath);
                    const now = new Date();
                    const thirtyMinutesAgo = new Date(now.getTime() - 30 * 60000);
                    if (lockFileStats.mtimeMs < thirtyMinutesAgo.getTime()) {
                        console.info('Lock file is older than 30 minutes, deleting');
                        fs.rmSync(lockFilePath);
                        clearInterval(interval);
                        resolve();
                    }
                }
            }, 1000);
        });
    }
};
const processWithLockFile = async (processFile, lockFilePath, isLockable) => {
    try {
        if (isLockable) {
            try {
                fs.writeFileSync(lockFilePath, '');
            }
            catch (error) {
                console.error('Error creating cache folder', error);
                throw error;
            }
        }
        return await processFile();
    }
    finally {
        if (fs.existsSync(lockFilePath)) {
            fs.rmSync(lockFilePath);
        }
    }
};
export const processFileOnHttp = async ({ fileUrl, processFile }) => {
    const gotStream = got.stream.get(fileUrl);
    const tmpFileBasename = uuid() + '-' + path.basename(new URL(fileUrl).pathname);
    const outStream = fs.createWriteStream('/tmp/' + tmpFileBasename);
    console.info('Attempting download from', fileUrl, 'to /tmp/' + tmpFileBasename);
    try {
        await pipeline(gotStream, outStream);
        console.info('Downloaded file', outStream.path);
        try {
            return await processFile({ file: path.normalize(outStream.path) });
        }
        catch (error) {
            console.error(`Error computing: ${error.message}`);
            throw error;
        }
    }
    catch (error) {
        console.error('Error downloading file', error);
        throw error;
    }
    finally {
        fs.rmSync(outStream.path);
    }
};
export const processFileOnShareOrHttp = async ({ shares, fileUrl, relativeCacheFolderPath, ignoreCache, version, canProcessFileOnHttp = false, processFile }) => {
    try {
        const match = findPathInShares(fileUrl, shares);
        const fileName = path.basename(match.filePath);
        const cacheDir = path.join(path.join(path.dirname(match.filePath), relativeCacheFolderPath), fileName);
        const cacheFilePath = path.join(cacheDir, `${fileName}.json`);
        const lockFilePath = path.join(cacheDir, `${fileName}.lock`);
        const cachedAssetsPath = path.join(match.share.systemRoot, relativeCacheFolderPath);
        if (match.share.cached) {
            if (!fs.existsSync(cacheDir)) {
                fs.mkdirSync(cacheDir, { recursive: true });
            }
            fs.chmodSync(cacheDir, 0o770);
            await waitForAlreadyRunningJob(lockFilePath);
            if (fs.existsSync(cacheFilePath) && !ignoreCache) {
                try {
                    const fileStats = fs.statSync(match.filePath);
                    const cacheFileStats = fs.statSync(cacheFilePath);
                    if (cacheFileStats.mtimeMs < fileStats.mtimeMs) {
                        console.info("Cached file is older than file, ignoring");
                    }
                    else {
                        const cachedData = readCached(cacheFilePath);
                        if (cachedData.version === version) {
                            return {
                                ...cachedData,
                                cached: true,
                                cachedAssetsPath,
                                version
                            };
                        }
                    }
                }
                catch (error) {
                    if (error.code === 'ENOENT') {
                        console.info('Cached file not found: ' + cacheFilePath);
                    }
                    else {
                        throw error;
                    }
                }
            }
        }
        try {
            const data = await processWithLockFile(() => processFile({ file: match.filePath, ...(match.share.cached && !ignoreCache && { cachePath: cacheDir }) }), lockFilePath, match.share.cached);
            if (match.share.cached) {
                try {
                    writeCached(cacheFilePath, { data, version });
                }
                catch (error) {
                    console.error("Error writing file", error);
                }
            }
            return {
                data,
                cached: false,
                ...(match.share.cached && { cachedAssetsPath }),
                version
            };
        }
        catch (error) {
            console.error(`Error computing: ${error.message}`);
            throw (error);
        }
    }
    catch (error) {
        console.error(error.message);
    }
    if (fileUrl.startsWith('http')) {
        if (canProcessFileOnHttp) {
            const data = await processFile({ file: fileUrl });
            return { data, cached: false, version };
        }
        try {
            const data = await processFileOnHttp({ fileUrl, processFile });
            return { data, cached: false, version };
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
    console.info('File was not found: ' + fileUrl);
    throw (new FileNotFoundError('File was not found: ' + fileUrl));
};
//# sourceMappingURL=shares.js.map